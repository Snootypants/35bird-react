Qa/hygene pass 2

===== run 1 =====

Summary
Found a rendering hot loop in useGameLoop that forces React to re-render every frame regardless of state changes.

Noted an accessibility regression where the Tab key is globally blocked, preventing keyboard users from reaching controls.

Identified a timer leak: hyperspace countdown timers keep running after unmount, risking “setState on unmounted component” warnings.

Issues
Excessive re-renders from useGameLoop
Calling setUiState unconditionally on every animation frame rebuilds the entire React tree ~60 times per second, despite the comment promising throttling. This wastes work whenever the derived refs haven’t changed.

Suggested task
Throttle UI updates inside useGameLoop

1. Open `src/hooks/useGameLoop.js` and track the last values pushed into `uiState` (e.g., store the previous snapshot in a `useRef`).
2. Before calling `setUiState`, compare the new values (`currencyRef.current`, `livesRef.current`, etc.) with the cached snapshot and skip the state setter if nothing changed.
3. Update the cached snapshot only when a setter actually fires, and add unit coverage (or a regression test) that asserts the setter isn’t invoked when refs stay constant.

Tab key accessibility regression
handleKeyDown prevents the default action for Tab before checking modifiers, so even a plain Tab press can’t move focus through overlays or buttons—breaking basic keyboard navigation.

Suggested task
Allow normal Tab navigation while keeping Shift+Tab shortcut

1. In `src/hooks/useGameControls.js`, adjust `handleKeyDown` so `e.preventDefault()` is only invoked when the key is actually handled (e.g., keep it for Space/Escape and for Tab when `e.shiftKey` is true).
2. Retain the Shift+Tab toggle path for the test console, but let an unmodified Tab fall through to the browser default.
3. Add a small regression test (e.g., with `@testing-library/user-event`) confirming that an unmodified Tab advances focus.

Hyperspace countdown timers survive unmount
startHyperCountdown registers both an interval and a timeout that keep mutating uiState, yet neither useGameWorld nor App tears them down on unmount, so navigating away can leave timers firing against an unmounted component.

Suggested task
Dispose hyperspace timers when the game unmounts

1. Inside `src/hooks/useGameWorld.js`, add a `useEffect` that returns `clearHyperCountdown` (and cancels any pending `setTimeout` created inside `startNewStage`) when the hook’s owner unmounts.
2. Ensure any secondary timers created in the hyperspace callback (e.g., the `setTimeout` wrapping `startNewStage`) are also tracked and cleared.
3. Verify (via test or manual repro in devtools) that unmounting `App` no longer triggers “state update on unmounted component” warnings.

==== run 2 ====

Findings
useGameLoop always calls setUiState with a freshly spread object each animation frame, even when none of the referenced values changed, so React re-renders at the frame rate despite the comment promising throttled updates.

Suggested task
Prevent unnecessary per-frame re-renders in useGameLoop

* In `src/hooks/useGameLoop.js`, add a `useRef` snapshot of the last values you pushed into `uiState`.
* Inside the loop, read the current refs (currency, lives, xp, level, hyperCountdown) into a plain object and compare it with the stored snapshot; bail out early if nothing changed.
* Only call `setUiState` when at least one value differs, returning either the existing `prev` object or the updated object, and then update the snapshot so React avoids redundant renders.

App.jsx is a 330+ line composition root that instantiates nearly all refs, hooks, and UI layers in one component, tightly coupling canvas setup, game logic wiring, overlays, and debug tooling, which makes it difficult to reason about or reuse any single concern.

Suggested task
Decompose App.jsx into focused modules

* Introduce a `GameProviders` (or similarly named) component under `src/game/` that encapsulates creation of refs/effects (`Ship`, `Camera`, effect refs) and returns structured contexts/hooks for consumers.
* Move overlay/test-console rendering into a new `GameUiLayer.jsx` component that receives only the derived UI state/handlers it needs.
* Update `App.jsx` to become a thin wrapper that composes `GameProviders`, `GameCanvas`, `GameUiLayer`, and HUD/debug components, wiring them via props/context instead of direct ref plumbing.
* Adjust imports and tests (`src/App.test.jsx`) to target the new component structure.

useGameWorld combines unrelated systems—starfield generation, loot drops, XP progression, stage progression, and hyperspace countdown timers—into a single 330-line hook, increasing cognitive load and making targeted changes risky.

Suggested task
Split useGameWorld into domain-specific hooks

* Extract starfield concerns into `useStarfield` (generating/updating stars) and return the `starsRef`.
* Move pickup/xp/currency logic into `useLootSystem`, exposing spawn/update/clear functions and currency/xp refs.
* Separate stage progression/hyperspace countdown into `useStageManager`, exposing `startNewStage`, `startHyperCountdown`, and asteroid count tracking.
* Have `useGameWorld` import and compose these hooks, returning their aggregated refs/functions so existing callers remain intact but each domain now has an isolated module.

The repository contains a full duplicate project under asteroids-game/ (including its own package.json, src/, and scripts), which is unused by the root build and creates ambiguity about the canonical source of truth.

Suggested task
Remove obsolete asteroids-game duplicate project

* Delete the entire `asteroids-game/` directory tree from version control.
* Update repository documentation (e.g., root `README.md` or `IMPROVEMENTS.md`) to remove references to the old path if present.
* Run lint/tests to ensure no import paths referenced the deleted copy and commit the cleanup.

==== run 3 ====

Findings
useGameLoop says it will “only update when values actually change,” but it always spreads prev into a brand-new object every frame, forcing React to rerender the whole tree even when the refs haven’t changed.

Suggested task
Stop per-frame UI churn in useGameLoop

1. Open `src/hooks/useGameLoop.js`.
2. Compute the next UI values from `currencyRef`, `livesRef`, `gameOverRef`, `xpRef`, `levelRef`, and `hyperCountdownRef` before calling `setUiState`.
3. In the state updater, compare those computed values against `prev`. If nothing changed, return `prev` to skip the rerender; otherwise return the updated object with the new values.
4. Keep the rest of the loop logic (rendering, `onFrame`, requestAnimationFrame) unchanged.

The game-over overlay reads from lastRun, but that state only updates when the player exits to the menu, so the summary panel shows stale defaults until you leave the game-over screen.

Suggested task
Capture last run stats when game over triggers

1. In `src/App.jsx`, add a ref to track the previous `uiState.gameOver` flag and a `useEffect` that runs when the flag (or the fields you need) changes.
2. When the effect sees a transition from `false` to `true`, call `setLastRun` with the current values (level/xp/currency from `uiState`, wave from `stageRef.current`, formatted timer string from `formattedTime`).
3. Remove the redundant `setLastRun` call inside `handleExitToMenu` in `src/hooks/useGameSession.js`, since the summary is now captured as soon as game-over happens.
4. Verify the overlay shows the correct stats immediately after a game over.

Legacy overlays (StartOverlay, the old GameOverOverlay, DeathOverlay, LifeLostOverlay) and the unused DeathEffect class are still checked into src/components/ and src/effects/, even though the UI now lives under src/components/ui. They add dead code and make the directory harder to navigate.

Suggested task
Remove superseded overlay/effect implementations

1. Delete the unused files `src/components/StartOverlay.jsx`, `src/components/GameOverOverlay.jsx`, `src/components/DeathOverlay.jsx`, `src/components/LifeLostOverlay.jsx`, and `src/effects/DeathEffect.js`.
2. Search the codebase for any lingering imports or references to those modules and remove them if found.
3. Run the existing build/test scripts to confirm nothing else relied on the deleted files.
4. Update documentation (if any) that still references the removed components to point at the `src/components/ui/` replacements.

==== run 4 ====

Summary
The game-over overlay renders lastRun stats that only update when returning to the main menu, so the immediate game-over screen shows stale defaults.

The game loop calls setUiState on every animation frame without checking for real changes, forcing needless React re-renders 60 times per second.

App.jsx couples nearly all refs, effects, hooks, and UI wiring in a single ~330‑line component, making the core orchestration hard to reason about or test in isolation.

DeathEffect remains in the codebase even though nothing imports it, leaving dead effect code to maintain.

Issues
Game-over stats never refresh until exiting to menu – The overlay uses lastRun for its readout, but that state is only written inside handleExitToMenu, after the player dismisses game over. Until then the overlay shows defaults or a prior run.

Suggested task
Capture run statistics when game over triggers

1. In `src/App.jsx`, track the previous `uiState.gameOver` in a `useRef` or similar guard.
2. Add a `useEffect` that fires when `uiState.gameOver` transitions from `false` to `true`; inside it, call `setLastRun` with the latest `uiState.level`, `uiState.currency`, `stageRef.current`, and `formattedTime`.
3. Verify the updated `lastRun` flows into `GameOverlayLayer` so the stats appear as soon as the game-over overlay opens.

useGameLoop forces unnecessary re-renders each frame – The hook comments about throttling UI updates, yet it still unconditionally calls setUiState, generating a new object every RAF tick. That will keep React in a permanent re-render cycle even when nothing changed.

Suggested task
Avoid redundant state writes in useGameLoop

1. In `src/hooks/useGameLoop.js`, create a `useRef` that caches the last `{currency, lives, gameOver, xp, level, hyperCountdownMs}` snapshot.
2. Each frame, build the next snapshot and shallow-compare it to the cached one; only call `setUiState` when at least one value differs.
3. Update the cached snapshot after a write, and ensure the hook’s effect dependencies stay accurate.

App.jsx mixes all orchestration concerns in one component – It owns dozens of refs, effect chains, hook wiring, rendering, and UI composition. The sheer scope (~330 lines) makes modifications risky and blocks targeted testing or reuse.

Suggested task
Decompose App.jsx into focused modules

1. Extract the large setup logic from `src/App.jsx` into a dedicated “game services” hook (e.g., `useGameRuntime`) that returns the refs and session objects; keep rendering concerns in `App`.
2. Move overlay/minimap/TestConsole rendering into separate container components that receive the pared-down state/handlers.
3. Ensure `App.jsx` primarily coordinates layout while the new modules encapsulate lifecycle concerns, then update imports accordingly.

Dead DeathEffect code remains unchecked – The project ships an unused effect implementation that nothing imports, adding maintenance load and potential confusion.

Suggested task
Remove unused DeathEffect implementation

1. Delete `src/effects/DeathEffect.js`.
2. Run a quick repository search to confirm no residual references; adjust any export barrels if they existed.
3. Update documentation or changelog if the effect was previously mentioned.